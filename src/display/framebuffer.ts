/**
 * M8 Framebuffer - Pixel-perfect rendering like m8c
 * 320Ã—240 pixel buffer with M8 font
 */

import type { Color, TextCommand, RectCommand, WaveCommand } from "../state/types";
// @ts-ignore - sharp default export
import sharp from "sharp";

// M8 screen dimensions
export const SCREEN_WIDTH = 320;
export const SCREEN_HEIGHT = 240;
export const CHAR_WIDTH = 8;
export const CHAR_HEIGHT = 10;

// M8 Stealth font (8x10 bitmap, ASCII 32-127)
// Each character is 10 bytes, each byte is 8 horizontal pixels
const M8_FONT: number[][] = [
  // Space (32)
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  // ! (33)
  [0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00, 0x00],
  // " (34)
  [0x00, 0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  // # (35)
  [0x00, 0x6C, 0xFE, 0x6C, 0x6C, 0xFE, 0x6C, 0x00, 0x00, 0x00],
  // $ (36)
  [0x10, 0x7C, 0xD0, 0x7C, 0x16, 0xFC, 0x10, 0x00, 0x00, 0x00],
  // % (37)
  [0x00, 0x66, 0xAC, 0xD8, 0x36, 0x6A, 0xCC, 0x00, 0x00, 0x00],
  // & (38)
  [0x00, 0x38, 0x4C, 0x38, 0x78, 0xCE, 0x7B, 0x00, 0x00, 0x00],
  // ' (39)
  [0x00, 0x18, 0x18, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  // ( (40)
  [0x00, 0x0C, 0x18, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00],
  // ) (41)
  [0x00, 0x30, 0x18, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00],
  // * (42)
  [0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00],
  // + (43)
  [0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00],
  // , (44)
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00],
  // - (45)
  [0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00],
  // . (46)
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00],
  // / (47)
  [0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x00, 0x00, 0x00],
  // 0 (48)
  [0x00, 0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00, 0x00, 0x00],
  // 1 (49)
  [0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00],
  // 2 (50)
  [0x00, 0x7C, 0xC6, 0x0C, 0x38, 0x60, 0xFE, 0x00, 0x00, 0x00],
  // 3 (51)
  [0x00, 0x7C, 0xC6, 0x1C, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // 4 (52)
  [0x00, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x00, 0x00, 0x00],
  // 5 (53)
  [0x00, 0xFE, 0xC0, 0xFC, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // 6 (54)
  [0x00, 0x7C, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // 7 (55)
  [0x00, 0xFE, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x00, 0x00, 0x00],
  // 8 (56)
  [0x00, 0x7C, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // 9 (57)
  [0x00, 0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x7C, 0x00, 0x00, 0x00],
  // : (58)
  [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00],
  // ; (59)
  [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00],
  // < (60)
  [0x00, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00, 0x00],
  // = (61)
  [0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
  // > (62)
  [0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00, 0x00],
  // ? (63)
  [0x00, 0x3C, 0x66, 0x0C, 0x18, 0x00, 0x18, 0x00, 0x00, 0x00],
  // @ (64)
  [0x00, 0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0x78, 0x00, 0x00, 0x00],
  // A (65)
  [0x00, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0x00, 0x00],
  // B (66)
  [0x00, 0xFC, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0x00, 0x00, 0x00],
  // C (67)
  [0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // D (68)
  [0x00, 0xF8, 0xCC, 0xC6, 0xC6, 0xCC, 0xF8, 0x00, 0x00, 0x00],
  // E (69)
  [0x00, 0xFE, 0xC0, 0xF8, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00],
  // F (70)
  [0x00, 0xFE, 0xC0, 0xF8, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00],
  // G (71)
  [0x00, 0x7C, 0xC6, 0xC0, 0xCE, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // H (72)
  [0x00, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00],
  // I (73)
  [0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00],
  // J (74)
  [0x00, 0x06, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // K (75)
  [0x00, 0xC6, 0xCC, 0xF8, 0xCC, 0xC6, 0xC6, 0x00, 0x00, 0x00],
  // L (76)
  [0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00],
  // M (77)
  [0x00, 0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00, 0x00, 0x00],
  // N (78)
  [0x00, 0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0x00, 0x00, 0x00],
  // O (79)
  [0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // P (80)
  [0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0x00, 0x00, 0x00],
  // Q (81)
  [0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xCE, 0x7C, 0x06, 0x00, 0x00],
  // R (82)
  [0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xCC, 0xC6, 0x00, 0x00, 0x00],
  // S (83)
  [0x00, 0x7C, 0xC0, 0x7C, 0x06, 0x06, 0x7C, 0x00, 0x00, 0x00],
  // T (84)
  [0x00, 0xFE, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00],
  // U (85)
  [0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // V (86)
  [0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00],
  // W (87)
  [0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, 0x00, 0x00],
  // X (88)
  [0x00, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00],
  // Y (89)
  [0x00, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00],
  // Z (90)
  [0x00, 0xFE, 0x0C, 0x18, 0x30, 0x60, 0xFE, 0x00, 0x00, 0x00],
  // [ (91)
  [0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00],
  // \ (92)
  [0x00, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00],
  // ] (93)
  [0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00],
  // ^ (94)
  [0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  // _ (95)
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00],
  // ` (96)
  [0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  // a (97)
  [0x00, 0x00, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00, 0x00, 0x00],
  // b (98)
  [0x00, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xFC, 0x00, 0x00, 0x00],
  // c (99)
  [0x00, 0x00, 0x7C, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // d (100)
  [0x00, 0x06, 0x06, 0x7E, 0xC6, 0xC6, 0x7E, 0x00, 0x00, 0x00],
  // e (101)
  [0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00, 0x00, 0x00],
  // f (102)
  [0x00, 0x1C, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00],
  // g (103)
  [0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x7C, 0x00, 0x00],
  // h (104)
  [0x00, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00],
  // i (105)
  [0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00],
  // j (106)
  [0x00, 0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0xCC, 0x78, 0x00, 0x00],
  // k (107)
  [0x00, 0xC0, 0xC0, 0xCC, 0xF8, 0xCC, 0xC6, 0x00, 0x00, 0x00],
  // l (108)
  [0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00],
  // m (109)
  [0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00, 0x00, 0x00],
  // n (110)
  [0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00],
  // o (111)
  [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00],
  // p (112)
  [0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0x00, 0x00],
  // q (113)
  [0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x00, 0x00],
  // r (114)
  [0x00, 0x00, 0xDC, 0xE6, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00],
  // s (115)
  [0x00, 0x00, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x00, 0x00, 0x00],
  // t (116)
  [0x00, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x1C, 0x00, 0x00, 0x00],
  // u (117)
  [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x00, 0x00, 0x00],
  // v (118)
  [0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00],
  // w (119)
  [0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00],
  // x (120)
  [0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00],
  // y (121)
  [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C, 0x00, 0x00],
  // z (122)
  [0x00, 0x00, 0xFE, 0x0C, 0x38, 0x60, 0xFE, 0x00, 0x00, 0x00],
  // { (123)
  [0x00, 0x0E, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00],
  // | (124)
  [0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00],
  // } (125)
  [0x00, 0x70, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00],
  // ~ (126)
  [0x00, 0x72, 0x9C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
];

/**
 * M8 Framebuffer - pixel-perfect rendering
 */
export class Framebuffer {
  private pixels: Uint8Array; // RGBA buffer
  private width = SCREEN_WIDTH;
  private height = SCREEN_HEIGHT;
  private lastUpdate = 0;

  constructor() {
    this.pixels = new Uint8Array(SCREEN_WIDTH * SCREEN_HEIGHT * 4);
    this.clear({ r: 0, g: 0, b: 0 });
  }

  /**
   * Clear entire screen
   */
  clear(color: Color): void {
    for (let i = 0; i < this.pixels.length; i += 4) {
      this.pixels[i] = color.r;
      this.pixels[i + 1] = color.g;
      this.pixels[i + 2] = color.b;
      this.pixels[i + 3] = 255;
    }
    this.lastUpdate = Date.now();
  }

  /**
   * Set pixel at x,y
   */
  setPixel(x: number, y: number, color: Color): void {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
    const idx = (y * this.width + x) * 4;
    this.pixels[idx] = color.r;
    this.pixels[idx + 1] = color.g;
    this.pixels[idx + 2] = color.b;
    this.pixels[idx + 3] = 255;
  }

  /**
   * Draw filled rectangle
   */
  drawRect(cmd: RectCommand): void {
    const { x, y, width, height, color } = cmd;
    for (let py = y; py < y + height && py < this.height; py++) {
      for (let px = x; px < x + width && px < this.width; px++) {
        if (px >= 0 && py >= 0) {
          this.setPixel(px, py, color);
        }
      }
    }
    this.lastUpdate = Date.now();
  }

  /**
   * Draw character with M8 font
   */
  drawChar(x: number, y: number, char: string, fg: Color, bg: Color): void {
    const code = char.charCodeAt(0);
    const glyphIndex = code - 32;

    // Get glyph data (default to space if out of range)
    const glyph = (glyphIndex >= 0 && glyphIndex < M8_FONT.length)
      ? M8_FONT[glyphIndex]
      : M8_FONT[0];

    // Draw background first
    for (let py = 0; py < CHAR_HEIGHT; py++) {
      for (let px = 0; px < CHAR_WIDTH; px++) {
        this.setPixel(x + px, y + py, bg);
      }
    }

    // Draw foreground pixels from glyph bitmap
    for (let py = 0; py < CHAR_HEIGHT && py < glyph.length; py++) {
      const row = glyph[py];
      for (let px = 0; px < CHAR_WIDTH; px++) {
        // Check if bit is set (MSB first)
        if (row & (0x80 >> px)) {
          this.setPixel(x + px, y + py, fg);
        }
      }
    }
    this.lastUpdate = Date.now();
  }

  /**
   * Apply TEXT command
   */
  applyText(cmd: TextCommand): void {
    this.drawChar(cmd.x, cmd.y, cmd.char, cmd.fg, cmd.bg);
  }

  /**
   * Apply RECT command
   */
  applyRect(cmd: RectCommand): void {
    this.drawRect(cmd);
  }

  /**
   * Apply WAVE command (waveform display)
   */
  applyWave(cmd: WaveCommand): void {
    const { color, data } = cmd;
    const waveHeight = 21;
    const waveY = 219; // Bottom of waveform area

    // Clear waveform area first
    for (let y = waveY - waveHeight; y <= waveY; y++) {
      for (let x = 0; x < Math.min(data.length, this.width); x++) {
        this.setPixel(x, y, { r: 0, g: 0, b: 0 });
      }
    }

    // Draw waveform
    for (let x = 0; x < data.length && x < this.width; x++) {
      const sample = data[x];
      const height = Math.floor((sample / 255) * waveHeight);
      for (let h = 0; h < height; h++) {
        this.setPixel(x, waveY - h, color);
      }
    }
    this.lastUpdate = Date.now();
  }

  /**
   * Get raw RGBA pixel data
   */
  getPixels(): Uint8Array {
    return this.pixels;
  }

  /**
   * Get last update timestamp
   */
  getLastUpdate(): number {
    return this.lastUpdate;
  }

  /**
   * Convert to base64 PNG (for web display)
   */
  toDataURL(): string {
    // Simple BMP encoding (no external deps)
    const bmp = this.toBMP();
    return `data:image/bmp;base64,${Buffer.from(bmp).toString("base64")}`;
  }

  /**
   * Convert to BMP format
   */
  toBMP(): Uint8Array {
    const w = this.width;
    const h = this.height;
    const rowSize = Math.ceil((w * 3) / 4) * 4; // Rows padded to 4 bytes
    const imageSize = rowSize * h;
    const fileSize = 54 + imageSize;

    const bmp = new Uint8Array(fileSize);
    const view = new DataView(bmp.buffer);

    // BMP Header
    bmp[0] = 0x42; bmp[1] = 0x4D; // "BM"
    view.setUint32(2, fileSize, true);
    view.setUint32(10, 54, true); // Pixel data offset

    // DIB Header
    view.setUint32(14, 40, true); // Header size
    view.setInt32(18, w, true);
    view.setInt32(22, -h, true); // Negative = top-down
    view.setUint16(26, 1, true); // Planes
    view.setUint16(28, 24, true); // Bits per pixel
    view.setUint32(34, imageSize, true);

    // Pixel data (BGR format, top-down due to negative height)
    let offset = 54;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const srcIdx = (y * w + x) * 4;
        bmp[offset++] = this.pixels[srcIdx + 2]; // B
        bmp[offset++] = this.pixels[srcIdx + 1]; // G
        bmp[offset++] = this.pixels[srcIdx];     // R
      }
      // Padding: each row must be aligned to 4 bytes
      const rowEnd = 54 + (y + 1) * rowSize;
      while (offset < rowEnd) {
        bmp[offset++] = 0;
      }
    }

    return bmp;
  }

  /**
   * Convert to JPEG format (compressed, ~15-30KB)
   */
  async toJPEG(quality: number = 70): Promise<Buffer> {
    return sharp(Buffer.from(this.pixels), {
      raw: {
        width: this.width,
        height: this.height,
        channels: 4,
      },
    })
      .jpeg({ quality })
      .toBuffer();
  }
}
