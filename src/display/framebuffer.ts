/**
 * M8 Framebuffer - Pixel-perfect rendering like m8c
 * 320×240 pixel buffer with M8 font
 * Font extracted from m8c font1.h (font_v1_small)
 */

import type { Color, TextCommand, RectCommand, WaveCommand } from "../state/types";

// M8 screen dimensions
export const SCREEN_WIDTH = 320;
export const SCREEN_HEIGHT = 240;

// M8 font dimensions (from m8c font_v1_small)
export const CHAR_WIDTH = 5;   // glyph_x
export const CHAR_HEIGHT = 7;  // glyph_y
export const TEXT_OFFSET_Y = 3; // text_offset_y from m8c

// M8 Font v1 small (5x7 pixels, extracted from m8c font1.h)
// ASCII 33-126 (94 characters). Space (32) is handled specially.
// Each row is 5 bits left-aligned in a byte (bits 7-3)
const M8_FONT: number[][] = [
  [0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80], // 33 '!'
  [0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00], // 34 '"'
  [0x00, 0x50, 0xf8, 0x50, 0xf8, 0x50, 0x00], // 35 '#'
  [0x20, 0xf8, 0xa0, 0xf8, 0x28, 0xf8, 0x20], // 36 '$'
  [0x00, 0xc8, 0xd0, 0x20, 0x58, 0x98, 0x00], // 37 '%'
  [0x60, 0x90, 0xa0, 0x48, 0xa8, 0x90, 0x68], // 38 '&'
  [0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00], // 39 '\''
  [0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08], // 40 '('
  [0x80, 0x40, 0x40, 0x40, 0x40, 0x40, 0x80], // 41 ')'
  [0x00, 0x50, 0x20, 0x50, 0x00, 0x00, 0x00], // 42 '*'
  [0x00, 0x20, 0x20, 0xf8, 0x20, 0x20, 0x00], // 43 '+'
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20], // 44 ','
  [0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00], // 45 '-'
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20], // 46 '.'
  [0x08, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80], // 47 '/'
  [0xf8, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0xf8], // 48 '0'
  [0x20, 0xe0, 0x20, 0x20, 0x20, 0x20, 0xf8], // 49 '1'
  [0xf8, 0x08, 0x08, 0xf8, 0x80, 0x80, 0xf8], // 50 '2'
  [0xf8, 0x08, 0x08, 0xf8, 0x08, 0x08, 0xf8], // 51 '3'
  [0x88, 0x88, 0x88, 0xf8, 0x08, 0x08, 0x08], // 52 '4'
  [0xf8, 0x80, 0x80, 0xf8, 0x08, 0x08, 0xf8], // 53 '5'
  [0xf8, 0x80, 0x80, 0xf8, 0x88, 0x88, 0xf8], // 54 '6'
  [0xf8, 0x08, 0x08, 0x10, 0x20, 0x20, 0x20], // 55 '7'
  [0x78, 0x88, 0x88, 0xf8, 0x88, 0x88, 0xf0], // 56 '8'
  [0xf8, 0x88, 0x88, 0xf8, 0x08, 0x08, 0x08], // 57 '9'
  [0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00], // 58 ':'
  [0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x40], // 59 ';'
  [0x00, 0x10, 0x30, 0x70, 0x30, 0x10, 0x00], // 60 '<'
  [0x00, 0x00, 0xf8, 0x00, 0xf8, 0x00, 0x00], // 61 '='
  [0x00, 0x40, 0x60, 0x70, 0x60, 0x40, 0x00], // 62 '>'
  [0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20], // 63 '?'
  [0x70, 0x88, 0xb8, 0xa8, 0xb8, 0x80, 0x70], // 64 '@'
  [0x70, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88], // 65 'A'
  [0xf0, 0x88, 0x88, 0xf0, 0x88, 0x88, 0xf0], // 66 'B'
  [0x70, 0x88, 0x80, 0x80, 0x80, 0x88, 0x70], // 67 'C'
  [0xf0, 0x88, 0x88, 0x88, 0x88, 0x88, 0xf0], // 68 'D'
  [0xf8, 0x80, 0x80, 0xf0, 0x80, 0x80, 0xf8], // 69 'E'
  [0xf8, 0x80, 0x80, 0xf0, 0x80, 0x80, 0x80], // 70 'F'
  [0x70, 0x88, 0x80, 0x80, 0x98, 0x88, 0x70], // 71 'G'
  [0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88], // 72 'H'
  [0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xf8], // 73 'I'
  [0x08, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70], // 74 'J'
  [0x88, 0x90, 0xa0, 0xc0, 0xa0, 0x90, 0x88], // 75 'K'
  [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf8], // 76 'L'
  [0x88, 0xd8, 0xa8, 0x88, 0x88, 0x88, 0x88], // 77 'M'
  [0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x88], // 78 'N'
  [0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70], // 79 'O'
  [0xf0, 0x88, 0x88, 0xf0, 0x80, 0x80, 0x80], // 80 'P'
  [0x70, 0x88, 0x88, 0x88, 0xa8, 0x90, 0x68], // 81 'Q'
  [0xf0, 0x88, 0x88, 0xf0, 0x90, 0x88, 0x88], // 82 'R'
  [0x78, 0x80, 0x80, 0x70, 0x08, 0x08, 0xf0], // 83 'S'
  [0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20], // 84 'T'
  [0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70], // 85 'U'
  [0x88, 0x88, 0x88, 0x88, 0x50, 0x50, 0x20], // 86 'V'
  [0x88, 0x88, 0x88, 0x88, 0xa8, 0xd8, 0x88], // 87 'W'
  [0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88], // 88 'X'
  [0x88, 0x88, 0x88, 0x78, 0x08, 0x08, 0xf0], // 89 'Y'
  [0xf8, 0x08, 0x10, 0x20, 0x40, 0x80, 0xf8], // 90 'Z'
  [0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18], // 91 '['
  [0x80, 0x80, 0x40, 0x20, 0x10, 0x08, 0x08], // 92 '\\'
  [0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xc0], // 93 ']'
  [0x20, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00], // 94 '^'
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8], // 95 '_'
  [0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00], // 96 '`'
  [0x00, 0x00, 0xf8, 0x08, 0xf8, 0x88, 0xf8], // 97 'a'
  [0x80, 0x80, 0xf8, 0x88, 0x88, 0x88, 0xf8], // 98 'b'
  [0x00, 0x00, 0xf8, 0x80, 0x80, 0x80, 0xf8], // 99 'c'
  [0x08, 0x08, 0xf8, 0x88, 0x88, 0x88, 0xf8], // 100 'd'
  [0x00, 0x00, 0xf8, 0x88, 0xf8, 0x80, 0xf8], // 101 'e'
  [0x38, 0x20, 0xf8, 0x20, 0x20, 0x20, 0x20], // 102 'f'
  [0x00, 0x00, 0xf8, 0x88, 0xf8, 0x08, 0xf8], // 103 'g'
  [0x80, 0x80, 0xf8, 0x88, 0x88, 0x88, 0x88], // 104 'h'
  [0x20, 0x00, 0x60, 0x20, 0x20, 0x20, 0x70], // 105 'i'
  [0x10, 0x00, 0x10, 0x10, 0x10, 0x10, 0xe0], // 106 'j'
  [0x80, 0x80, 0x88, 0x90, 0xa0, 0xd0, 0x88], // 107 'k'
  [0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70], // 108 'l'
  [0x00, 0x00, 0xf8, 0xa8, 0xa8, 0xa8, 0xa8], // 109 'm'
  [0x00, 0x00, 0xf8, 0x88, 0x88, 0x88, 0x88], // 110 'n'
  [0x00, 0x00, 0xf8, 0x88, 0x88, 0x88, 0xf8], // 111 'o'
  [0x00, 0x00, 0xf8, 0x88, 0x88, 0xf8, 0x80], // 112 'p'
  [0x00, 0x00, 0xf8, 0x88, 0x88, 0xf8, 0x08], // 113 'q'
  [0x00, 0x00, 0xf8, 0x80, 0x80, 0x80, 0x80], // 114 'r'
  [0x00, 0x00, 0xf8, 0x80, 0xf8, 0x08, 0xf8], // 115 's'
  [0x20, 0x20, 0xf8, 0x20, 0x20, 0x20, 0x38], // 116 't'
  [0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0xf8], // 117 'u'
  [0x00, 0x00, 0x88, 0x88, 0x90, 0xa0, 0xc0], // 118 'v'
  [0x00, 0x00, 0xa8, 0xa8, 0xa8, 0xa8, 0xf8], // 119 'w'
  [0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88], // 120 'x'
  [0x00, 0x00, 0x88, 0x88, 0xf8, 0x08, 0xf8], // 121 'y'
  [0x00, 0x00, 0xf8, 0x10, 0x20, 0x40, 0xf8], // 122 'z'
  [0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0xf8], // 123 '{'
  [0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20], // 124 '|'
  [0xf8, 0x88, 0x88, 0xa8, 0x88, 0x88, 0xf8], // 125 '}'
  [0x00, 0x48, 0xb0, 0x00, 0x00, 0x00, 0x00], // 126 '~'
];

/**
 * M8 Framebuffer - pixel-perfect rendering
 */
export class Framebuffer {
  private pixels: Uint8Array; // RGBA buffer
  private width = SCREEN_WIDTH;
  private height = SCREEN_HEIGHT;
  private lastUpdate = 0;

  constructor() {
    this.pixels = new Uint8Array(SCREEN_WIDTH * SCREEN_HEIGHT * 4);
    this.clear({ r: 0, g: 0, b: 0 });
  }

  /**
   * Clear entire screen
   */
  clear(color: Color): void {
    for (let i = 0; i < this.pixels.length; i += 4) {
      this.pixels[i] = color.r;
      this.pixels[i + 1] = color.g;
      this.pixels[i + 2] = color.b;
      this.pixels[i + 3] = 255;
    }
    this.lastUpdate = Date.now();
  }

  /**
   * Set pixel at x,y
   */
  setPixel(x: number, y: number, color: Color): void {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
    const idx = (y * this.width + x) * 4;
    this.pixels[idx] = color.r;
    this.pixels[idx + 1] = color.g;
    this.pixels[idx + 2] = color.b;
    this.pixels[idx + 3] = 255;
  }

  /**
   * Get pixel color at x,y (for testing)
   */
  getPixel(x: number, y: number): Color {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
      return { r: 0, g: 0, b: 0 };
    }
    const idx = (y * this.width + x) * 4;
    return {
      r: this.pixels[idx],
      g: this.pixels[idx + 1],
      b: this.pixels[idx + 2],
    };
  }

  /**
   * Draw filled rectangle
   */
  drawRect(cmd: RectCommand): void {
    const { x, y, width, height, color } = cmd;
    for (let py = y; py < y + height && py < this.height; py++) {
      for (let px = x; px < x + width && px < this.width; px++) {
        if (px >= 0 && py >= 0) {
          this.setPixel(px, py, color);
        }
      }
    }
    this.lastUpdate = Date.now();
  }

  /**
   * Draw character with M8 font (5x7 like m8c)
   * Applies TEXT_OFFSET_Y to Y position (same as m8c)
   */
  drawChar(x: number, y: number, char: string, fg: Color, bg: Color): void {
    const code = char.charCodeAt(0);

    // Apply text_offset_y (like m8c: command->pos.y + text_offset_y)
    const drawY = y + TEXT_OFFSET_Y;

    // Draw background first (glyph_x × glyph_y area)
    for (let py = 0; py < CHAR_HEIGHT; py++) {
      for (let px = 0; px < CHAR_WIDTH; px++) {
        this.setPixel(x + px, drawY + py, bg);
      }
    }

    // Space (ASCII 32) has no glyph - only background
    if (code === 32) {
      this.lastUpdate = Date.now();
      return;
    }

    // Get glyph index (ASCII 33-126 maps to index 0-93)
    const glyphIndex = code - 33;
    if (glyphIndex < 0 || glyphIndex >= M8_FONT.length) {
      // Character not in font - just draw background
      this.lastUpdate = Date.now();
      return;
    }

    const glyph = M8_FONT[glyphIndex];

    // Draw foreground pixels from glyph bitmap
    for (let py = 0; py < CHAR_HEIGHT && py < glyph.length; py++) {
      const row = glyph[py];
      for (let px = 0; px < CHAR_WIDTH; px++) {
        // Check if bit is set (MSB first, bits 7-3 are the 5 pixels)
        if (row & (0x80 >> px)) {
          this.setPixel(x + px, drawY + py, fg);
        }
      }
    }
    this.lastUpdate = Date.now();
  }

  /**
   * Apply TEXT command
   */
  applyText(cmd: TextCommand): void {
    this.drawChar(cmd.x, cmd.y, cmd.char, cmd.fg, cmd.bg);
  }

  /**
   * Apply RECT command
   */
  applyRect(cmd: RectCommand): void {
    this.drawRect(cmd);
  }

  /**
   * Apply WAVE command (waveform display)
   * Waveform is drawn in top-right corner (like m8c)
   * Each sample byte IS the Y coordinate (0-24), not a height!
   */
  applyWave(cmd: WaveCommand): void {
    const { color, data } = cmd;
    const waveMaxHeight = 24;
    const waveX = this.width - data.length; // Right-aligned

    // Clear waveform area first (top-right corner only)
    for (let y = 0; y < waveMaxHeight + 1; y++) {
      for (let x = waveX; x < this.width; x++) {
        if (x >= 0) {
          this.setPixel(x, y, { r: 0, g: 0, b: 0 });
        }
      }
    }

    // Draw waveform - each sample IS the Y coordinate (like m8c)
    for (let i = 0; i < data.length && waveX + i < this.width; i++) {
      let sample = data[i];
      // Clamp to max height
      if (sample > waveMaxHeight) {
        sample = waveMaxHeight;
      }
      // Draw point at (x, y) where y = sample value directly
      this.setPixel(waveX + i, sample, color);
    }
    this.lastUpdate = Date.now();
  }

  /**
   * Get raw RGBA pixel data
   */
  getPixels(): Uint8Array {
    return this.pixels;
  }

  /**
   * Get last update timestamp
   */
  getLastUpdate(): number {
    return this.lastUpdate;
  }

  /**
   * Export as BMP (uncompressed 24-bit)
   */
  toBMP(): Buffer {
    const width = this.width;
    const height = this.height;
    const rowSize = Math.ceil((width * 3) / 4) * 4; // Rows padded to 4 bytes
    const pixelDataSize = rowSize * height;
    const fileSize = 54 + pixelDataSize; // Header + pixels

    const buffer = Buffer.alloc(fileSize);

    // BMP Header (14 bytes)
    buffer.write("BM", 0);
    buffer.writeUInt32LE(fileSize, 2);
    buffer.writeUInt32LE(0, 6); // Reserved
    buffer.writeUInt32LE(54, 10); // Pixel data offset

    // DIB Header (40 bytes)
    buffer.writeUInt32LE(40, 14); // Header size
    buffer.writeInt32LE(width, 18);
    buffer.writeInt32LE(height, 22); // Positive = bottom-up
    buffer.writeUInt16LE(1, 26); // Planes
    buffer.writeUInt16LE(24, 28); // Bits per pixel
    buffer.writeUInt32LE(0, 30); // No compression
    buffer.writeUInt32LE(pixelDataSize, 34);
    buffer.writeInt32LE(2835, 38); // X pixels/meter
    buffer.writeInt32LE(2835, 42); // Y pixels/meter
    buffer.writeUInt32LE(0, 46); // Colors in palette
    buffer.writeUInt32LE(0, 50); // Important colors

    // Pixel data (bottom-up, BGR)
    let offset = 54;
    for (let y = height - 1; y >= 0; y--) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        buffer[offset++] = this.pixels[idx + 2]; // B
        buffer[offset++] = this.pixels[idx + 1]; // G
        buffer[offset++] = this.pixels[idx]; // R
      }
      // Pad row to 4 bytes
      while (offset % 4 !== 54 % 4) {
        buffer[offset++] = 0;
      }
    }

    return buffer;
  }
}
